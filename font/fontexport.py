#!/usr/bin/python

#Link me to gimp's plugins dir
#ex: `ln -s fontexport.py ~/snap/gimp/current/.config/GIMP/2.10/plug-ins/fontexport.py`

# `.vscode/settings.json` example:
# {
#     "python.pythonPath": "/usr/bin/python2",
#     "python.envFile": "${workspaceFolder}/.vscode/.env"
# }
#
# `.vscode/.env` example:
# PYTHONPATH="/snap/gimp/current/usr/bin/python"
# If you start gimp from the command line, you can see any errors or print calls.
# The headers and preview image will be saved to the directory you run gimp from.
# If this loads, you should have an "ATA Export Font" menu option.

# Renders characters using the configured values, outputs a C header with the integer representation and png preview.
# Each char is represented by an array of bit-masks representing each row in the char render either in 0b or hex literals.

import math
from gimpfu import *
import binascii
import os
import math

font_name = "Ubuntu Mono"
font_size = 8
char_start = ' '
char_end = '~'
char_count = ord(char_end) - ord(char_start) + 1


# This only affects how the preview png is generated.
col_count = 16

col_width = font_size/2
row_height = font_size

# Write to header with 0b integer rather than hex.
write_binary_ints = True

base_file_name = "ata_mono{0}".format(row_height)

img_out_path = os.path.abspath("{0}.png".format(base_file_name))
header_out_path = os.path.abspath("{0}.h".format(base_file_name))
impl_out_path = os.path.abspath("{0}.c".format(base_file_name))

white_color = gimpcolor.RGB(255, 255, 255)
black_color = gimpcolor.RGB(0, 0, 0)

def char_range(start, end):
    for c in range(ord(start), ord(end)+1):
        yield(chr(c))

def layer_to_introws(layer):
    rgn = layer.get_pixel_rgn(0, 0, layer.width, layer.height)

    rows = []

    for y in range(0, layer.height):
        row_val = 0
        for x in range(0, layer.width):
            pixel = bytearray(rgn[x, y])
            if pixel[0] > 0:
                row_val |= 1<<x

        rows.append(row_val)

    return rows

def write_ints_to_c(int_rows):
    f = open(header_out_path, "w")
    f.write("#pragma once\n\n")
    f.write("#include <stdint.h>\n")
    f.write("#include \"ssd-1306-i2c.h\"\n\n")
    f.write("// Generated by fontexport.py plugin for Gimp\n")
    f.write("\n")
    f.write("// Each character is represented by {0} rows of integers representing the bit mask for each rows.\n".format(row_height))
    f.write(("uint32_t {0}_data[{1}][{2}];\n\n").format(base_file_name, char_count, row_height))
    f.write("#define CREATE_{0}() ({{  \\\n".format(base_file_name.upper()))
    f.write("    canvas_font_handle __ret = init_canvas_font(\"{0}\", {1}, {2}, \'{3}\', \'{4}\', (uint32_t*){5}_data);  \\\n".format(base_file_name, col_width, row_height, char_start, char_end, base_file_name))
    f.write("    (__ret);  \\\n")
    f.write("})\n")
    f.close()

    f = open(impl_out_path, "w")
    f.write("#include \"{0}.h\"\n\n".format(base_file_name))
    f.write("// Generated by fontexport.py plugin for Gimp\n")
    f.write(("uint32_t {0}_data[{1}][{2}] = {{\n").format(base_file_name, char_count, row_height))

    for row_name, vals in sorted(int_rows.items()):
        f.write("    //char '{0}'\n".format(row_name))
        
        if write_binary_ints:
            f.write("    {\n")
            f.write(",\n".join(map(lambda int_val: "        0b{0:0{1}b}".format(int_val, col_width), vals)))
            f.write("\n    },\n")
        else:
            f.write("    {")
            f.write(", ".join(map(lambda int_val: hex(int_val), vals)))
            f.write("}\n")

    f.write("};")
    f.close()

    print("Saved to {0}".format(header_out_path))

def render_char(char, img):
    text_layer = pdb.gimp_text_fontname(img, None, 0, 0, char, 0, False, font_size, PIXELS, font_name)

    dx = col_width - text_layer.width
    dy = row_height - text_layer.height

    text_layer.resize(col_width, row_height, dx/2, dy/2)

    pdb.gimp_layer_set_offsets(text_layer, 0, 0)

    return text_layer

def init_background_img():
    row_count = math.ceil(float(char_count) / col_count)
    img_width = col_width * col_count
    img_height = row_height * row_count

    img=pdb.gimp_image_new(img_width, img_height, RGB)
    pdb.gimp_context_set_foreground(black_color)
    layer=pdb.gimp_layer_new(img, img_width, img_height, RGB, "base", 100, NORMAL_MODE)
    pdb.gimp_image_add_layer(img, layer, 0)

    return img

def run_export():
    int_rows = {}
    img = init_background_img()
    char_idx = 0

    pdb.gimp_context_set_foreground(white_color)

    for c in char_range(char_start, char_end):
        text_layer = render_char(c, img)
        int_rows[c] = layer_to_introws(text_layer)

        col_idx = char_idx % col_count
        row_idx = char_idx / col_count

        pdb.gimp_layer_set_offsets(text_layer, col_idx * col_width, row_idx * row_height)

        char_idx += 1
        
    write_ints_to_c(int_rows)

    combined = pdb.gimp_image_merge_visible_layers(img, CLIP_TO_IMAGE)
    pdb.gimp_file_save(img, combined, img_out_path, '?')

    pdb.gimp_display_new(img)

    gimp.message("Saved to {0}".format(header_out_path))

register(
    "Ata_Export_Font",
    "Render a font as a C header",
    "Renders the specified character range in gimp, exports a C header representation and a png preview.",
    "Alex Raboud",
    "Alex Raboud",
    "2021",
    "<Toolbox>/ATA Export Font",
    "",
    [],
    [],
    run_export
)

main()