#!/usr/bin/python

#Link me to python plugins dir
#ex: `ln -s fontexport.py ~/snap/gimp/current/.config/GIMP/2.10/plug-ins/fontexport.py`

# `.vscode/settings.json` example:
# {
#     "python.pythonPath": "/usr/bin/python2",
#     "python.envFile": "${workspaceFolder}/.vscode/.env"
# }
#
# `.vscode/.env` example:
# PYTHONPATH="/snap/gimp/current/usr/bin/python"

# Renders characters using the hardcoded config values, outputs a c header and png preview.
# Each char is represented by an array of bit-masks representing each row in the char render (MSB, top to bottom).

import math
from gimpfu import *
import binascii
import os
import math

font_name = "Verdana Bold"
font_size = 16
col_count = 16
col_width = 16
row_height = 18
char_start = '$'
char_end = '~'

img_out_path = os.path.abspath("ata_monospace16.png")
header_out_path = os.path.abspath("ata_monospace16.h")

white_color = gimpcolor.RGB(255, 255, 255)
black_color = gimpcolor.RGB(0, 0, 0)

def char_range(start, end):
    for c in range(ord(char_start), ord(char_end)+1):
        yield(chr(c))

def layer_to_introws(layer):
    rgn = layer.get_pixel_rgn(0, 0, layer.width, layer.height)

    rows = []

    for y in range(0, layer.height):
        row_val = int(0)
        for x in range(0, layer.width):
            pixel = bytearray(rgn[layer.width-1-x, y])
            if pixel[0] > 0:
                row_val |= (1<<x)
            
        rows.append(row_val)

    print(rows)

    return rows

def write_ints_to_c_header(int_rows):
    f = open(header_out_path, "w")

    f.write("#pragma once\n\n")
    f.write("#include <stdint.h>\n\n")
    f.write("// Generated by fontexport.py plugin for Gimp\n")
    f.write("// Each character is represented by {0} rows int's representing the bit mask for each rows. MSB, top to bottom.\n".format(row_height))
    f.write(("uint16_t ata_monospace16[ ][{0}] = {{\n").format(row_height))

    for row_name in int_rows:
        f.write("    //char '{0}'\n".format(row_name))
        f.write("    {")
        f.write(", ".join(map(lambda int_val: hex(int_val), int_rows[row_name])))
        f.write("},\n")
    
    f.write("};\n")

    f.close()

    print("Saved to {0}".format(header_out_path))


def generate_bitmap():
    int_rows = {}

    char_count = sum(1 for _ in char_range(char_start, char_end))
    row_count = math.ceil(float(char_count) / col_count)
    img_width = col_width * col_count
    img_height = row_height * row_count

    print("Got count: {0}".format(row_count))

    img=pdb.gimp_image_new(img_width, img_height, RGB)
    pdb.gimp_context_set_foreground(black_color)
    layer=pdb.gimp_layer_new(img, img_width, img_height, RGB, "base", 100, NORMAL_MODE)
    pdb.gimp_image_add_layer(img, layer, 0)
    
    pdb.gimp_context_set_foreground(white_color)

    char_idx = 0

    for c in char_range(char_start, char_end):
        
        new_text = pdb.gimp_text_fontname(img, None, 0, 0, c, 0, False, font_size, PIXELS, font_name)

        dx = col_width - new_text.width
        dy = row_height - new_text.height

        new_text.resize(col_width, row_height, dx/2, dy/2)

        pdb.gimp_layer_set_offsets(new_text, 0, 0)

        int_rows[c] = layer_to_introws(new_text)
        
        col_idx = char_idx % col_count
        row_idx = char_idx / col_count

        pdb.gimp_layer_set_offsets(new_text, col_idx * col_width, row_idx * row_height)

        char_idx += 1
        
    write_ints_to_c_header(int_rows)

    combined = pdb.gimp_image_merge_visible_layers(img, CLIP_TO_IMAGE)
    pdb.gimp_file_save(img, combined, img_out_path, '?')

    pdb.gimp_display_new(img)

    gimp.message("Saved to {0}".format(header_out_path))


def run_export():
    generate_bitmap()

register(
    "Ata_Export_Font",
    "Export the font layers as byte-code",
    "Export the font layers as byte-code",
    "Alex Raboud",
    "Alex Raboud",
    "2021",
    "<Toolbox>/ATA Export Font",
    "",
    [],
    [],
    run_export
)

main()